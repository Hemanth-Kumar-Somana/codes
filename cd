5. Write a Lex program to count the number of words and lines in a given file or program.
# ‚úÖ **LEX Program: Count Words and Lines**

Save this as **count.l**

```lex
%{
int word_count = 0;
int line_count = 0;
%}

%%

[ \t]+          ;              /* Ignore spaces/tabs */
\n              { line_count++; }
[A-Za-z0-9_]+   { word_count++; }

.               ;              /* Ignore other characters */

%%

int main() {
    yylex();
    printf("Total Lines : %d\n", line_count);
    printf("Total Words : %d\n", word_count);
    return 0;
}

int yywrap() {
    return 1;
}
```

---

# ‚úÖ **How It Works**

| Pattern         | Action                                     |
| --------------- | ------------------------------------------ |
| `[ \t]+`        | Skip spaces/tabs                           |
| `\n`            | Count each newline as a line               |
| `[A-Za-z0-9_]+` | Count any sequence of characters as a word |
| `.`             | Ignore everything else                     |

---

# üõ†Ô∏è **To Compile and Run**

1. Generate C code:

```
lex count.l
```

2. Compile using gcc:

```
gcc lex.yy.c -o count
```

3. Run the program with a file:

```
./count < filename.txt
```

---

If you want, I can also give a version that counts **characters**, or **counts specific tokens**, or handles **comments in C programs**.
6. Write a recursive descent parser for the grammar:

S ‚Üí (L) | a

L ‚Üí L , S | S



#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char input[100];
int pos = 0;

char get() {
    return input[pos];
}

void advance() {
    pos++;
}

void error() {
    printf("Invalid string\n");
    exit(1);
}

void S();
void L();
void Lprime();

void S() {
    if (get() == '(') {
        advance();
        L();
        if (get() != ')') error();
        advance();
    }
    else if (get() == 'a') {
        advance();
    }
    else {
        error();
    }
}

void L() {
    S();
    Lprime();
}

void Lprime() {
    while (get() == ',') {
        advance();
        S();
    }
}

int main() {
    printf("Enter string: ");
    scanf("%s", input);

    S();

    if (get() == '\0')
        printf("Valid string\n");
    else
        printf("Invalid string\n");

    return 0;
}
```

---

# ‚úî Valid Examples

```
a
(a)
(a,a)
((a),a)
(a,(a,a))
```

# ‚ùå Invalid Examples

```
()
(,)
(a,
a)
((a),)
```



7. Write a YACC program to evaluate an algebraic expression.
Below is a **clean, simple, fully working YACC program** that evaluates an algebraic expression with operators:

‚úî `+ , - , * , /`
‚úî parentheses `()`
‚úî supports multi-digit numbers

Includes both **LEX** and **YACC** files.

---

# ‚úÖ **LEX File (expr.l)**

```lex
%{
#include "y.tab.h"
%}

%%

[0-9]+      { yylval = atoi(yytext); return NUMBER; }
[ \t\n]     { /* ignore spaces */ }
.           { return yytext[0]; }

%%

int yywrap() {
    return 1;
}
```

---

# ‚úÖ **YACC File (expr.y)**

```yacc
%{
#include <stdio.h>
#include <stdlib.h>

int yylex();
void yyerror(const char *s) {
    printf("Error: %s\n", s);
}
%}

%token NUMBER

%%

E  : E '+' T      { $$ = $1 + $3; }
   | E '-' T      { $$ = $1 - $3; }
   | T            { $$ = $1; }
   ;

T  : T '*' F      { $$ = $1 * $3; }
   | T '/' F      { $$ = $1 / $3; }
   | F            { $$ = $1; }
   ;

F  : '(' E ')'    { $$ = $2; }
   | NUMBER       { $$ = $1; }
   ;

%%

int main() {
    printf("Enter expression: ");
    yyparse();
    return 0;
}
```

---

# üõ† **How to Compile and Run**

Open terminal and run:

```
yacc -d expr.y
lex expr.l
cc lex.yy.c y.tab.c -o expr
./expr
```

---

# ‚ñ∂ Example Input

```
10 + 20 * 3 - (4 + 6)
```

# ‚ñ∂ Output

```
Enter expression: 10 + 20 * 3 - (4 + 6)
44
```

-------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>

int main() {
    char input[100];
    int state = 0;  // q0

    printf("Enter a binary string: ");
    scanf("%s", input);

    for (int i = 0; i < strlen(input); i++) {
        char c = input[i];

        switch (state) {

            case 0: // q0
                if (c == '0')
                    state = 1;  // go to q1
                else if (c == '1')
                    state = 3;  // go to q3
                else {
                    printf("Invalid input.\n");
                    return 0;
                }
                break;

            case 1: // q1: last char = 0
                if (c == '0')
                    state = 2;  // q2 (00)
                else if (c == '1')
                    state = 3;  // q3
                else {
                    printf("Invalid input.\n");
                    return 0;
                }
                break;

            case 2: // q2: last two = 00 (reject state)
                if (c == '0')
                    state = 2;  // stays in reject state
                else if (c == '1')
                    state = 3;  // exit reject state
                else {
                    printf("Invalid input.\n");
                    return 0;
                }
                break;

            case 3: // q3: last char = 1
                if (c == '0')
                    state = 1;  // q1
                else if (c == '1')
                    state = 3;  // stay q3
                else {
                    printf("Invalid input.\n");
                    return 0;
                }
                break;
        }
    }

    // FINAL CHECK
    if (state == 2)
        printf("Rejected: String ends with 00.\n");
    else
        printf("Accepted: String does NOT end with 00.\n");

    return 0;
}

---------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>

int main() {
    char input[100];
    int state = 0;  // q0 = 0 (accept), q1 = 1 (reject)

    printf("Enter a binary string: ");
    scanf("%s", input);

    // DFA Processing
    for (int i = 0; i < strlen(input); i++) {
        if (input[i] == '0') {
            state = 0;   // Move to q0
        } 
        else if (input[i] == '1') {
            state = 1;   // Move to q1
        } 
        else {
            printf("Invalid input (only 0 and 1 allowed)\n");
            return 0;
        }
    }

    // Final State Check
    if (state == 0)
        printf("Accepted: Even binary number.\n");
    else
        printf("Rejected: Odd binary number.\n");

    return 0;
}




